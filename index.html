<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8"/>
<meta name="viewport" content="width=device-width,initial-scale=1"/>
<title>Topf schlagen â€” keyboard-only</title>
<style>
  :root{
    --bg:#071428;
    --fg:#dff3ff;
    --muted:#9fbfe0;
    --panel-radius:18px;
  }
  html,body{height:100%;margin:0;font-family:Inter,system-ui,Segoe UI,Roboto,Arial;background:linear-gradient(180deg,#051026,#082033);color:var(--fg);}
  .wrap{max-width:820px;margin:28px auto;padding:22px;border-radius:16px;background:linear-gradient(180deg, rgba(255,255,255,0.02), rgba(255,255,255,0.01));box-shadow:0 10px 40px rgba(2,6,23,.6);}
  header{display:flex;align-items:center;justify-content:space-between;gap:12px}
  h1{margin:0;font-size:20px}
  p.lead{margin:6px 0 14px;color:var(--muted);font-size:14px}
  .game{
    display:grid;
    grid-template-columns: 1fr 320px;
    gap:18px;align-items:start;
  }

  /* the big color panel */
  .colorPanel{
    height:360px;border-radius:var(--panel-radius);display:flex;flex-direction:column;align-items:center;justify-content:center;
    transition:background-color .24s linear, box-shadow .24s ease; position:relative; overflow:hidden;
    box-shadow: inset 0 8px 30px rgba(0,0,0,.45);
  }
  .centerKey{
    font-size:92px;font-weight:800;letter-spacing:4px;color:rgba(255,255,255,0.95);text-shadow:0 8px 30px rgba(0,0,0,.5);
    transition:transform .18s ease;
  }
  .sub{
    margin-top:8px;color:rgba(255,255,255,0.9);font-weight:600;font-size:16px;
  }
  .meta{
    position:absolute;left:14px;top:14px;color:rgba(255,255,255,0.85);font-weight:600;font-size:13px;
  }
  .hint{
    position:absolute;right:14px;top:14px;color:rgba(255,255,255,0.7);font-size:13px;
  }

  /* side panel */
  .side{
    background:linear-gradient(180deg, rgba(255,255,255,0.02), rgba(255,255,255,0.01));
    padding:16px;border-radius:12px;height:360px;box-shadow:0 6px 24px rgba(0,0,0,.45);display:flex;flex-direction:column;justify-content:space-between;
  }
  .section{margin-bottom:12px}
  .label{color:var(--muted);font-size:13px;margin-bottom:8px}
  .allowedRow{display:flex;flex-wrap:wrap;gap:8px}
  .chip{
    padding:8px 12px;border-radius:10px;background:rgba(255,255,255,0.03);font-weight:700; min-width:44px;text-align:center;
    box-shadow: inset 0 -2px 6px rgba(0,0,0,.3);
    transition:transform .12s ease, background .16s ease;
    user-select:none;
  }
  .chip.allowed{background:rgba(255,255,255,0.08);cursor:default}
  .chip.space{min-width:78px}
  .msg{padding:10px;border-radius:10px;background:rgba(255,255,255,0.02);color:var(--muted);font-size:13px}
  .controls{display:flex;gap:8px;align-items:center}
  .btn{padding:8px 12px;border-radius:10px;background:rgba(255,255,255,0.03);border:1px solid rgba(255,255,255,0.04);cursor:pointer;color:var(--fg)}
  .btn.important{background:linear-gradient(90deg,#2fd675,#06f2a6);color:#04211a;border:none}
  .footer{color:var(--muted);font-size:13px;text-align:center;margin-top:8px}

  .warning{color:#ffd9d9;background:rgba(255,12,12,0.06);padding:8px;border-radius:8px;margin-top:8px;font-weight:700}

  @media (max-width:900px){
    .game{grid-template-columns:1fr}
    .side{height:auto}
    .colorPanel{height:320px}
  }
</style>
</head>
<body>
  <div class="wrap" role="application" aria-label="Topf schlagen keyboard-only">
    <header>
      <div>
        <h1>Topf schlagen â€” keyboard-only</h1>
        <p class="lead">Press any physical key to start. You must move one step at a time â€” only the allowed next keys (shown) will be accepted.</p>
      </div>
      <div style="text-align:right;color:var(--muted);font-size:13px">
        Treasure: <strong id="treasureHint">hidden</strong><br/>
        Moves: <strong id="moves">0</strong>
      </div>
    </header>

    <main class="game" id="game">
      <div class="colorPanel" id="colorPanel" aria-live="polite">
        <div class="meta" id="meta"></div>
        <div class="hint">Color = distance to treasure (closer â†’ red)</div>
        <div class="centerKey" id="centerKey">â€”</div>
        <div class="sub" id="subText">Press any key to choose a starting key.</div>
      </div>

      <aside class="side" aria-hidden="false">
        <div>
          <div class="section">
            <div class="label">Last pressed key</div>
            <div class="msg" id="lastKey">â€”</div>
          </div>

          <div class="section">
            <div class="label">Allowed next keys (press one)</div>
            <div class="allowedRow" id="allowedRow">
              <!-- chips inserted here -->
            </div>
          </div>

          <div id="warningArea" style="min-height:36px"></div>
        </div>

        <div>
          <div style="display:flex;gap:8px;align-items:center;">
            <button class="btn" id="revealBtn">Reveal treasure</button>
            <button class="btn important" id="restartBtn">Restart (Enter)</button>
          </div>
          <div class="footer">Only keyboard input is required. Space is supported.</div>
        </div>
      </aside>
    </main>
  </div>

<script>
/*
  Topf schlagen â€” keyboard-only implementation
  - No on-screen keyboard. Show a color (distance), last pressed key, and allowed next keys (one-step neighbors).
  - Accepts letters a-z and Space as keys.
  - Start by pressing any allowed key (first press accepted). Subsequent presses must be one-step neighbors.
  - Treasure is a random key from the set. Press Enter to restart.
*/

(function(){
  // QWERTY-like rows (letters). We include space as extra key.
  const rows = [
    ['q','w','e','r','t','y','u','i','o','p'],
    ['a','s','d','f','g','h','j','k','l'],
    ['z','x','c','v','b','n','m']
  ];

  // We'll create key positions in a 2D coordinate system (x = column + offset[row], y = row)
  // Offsets approximate physical keyboard staggering
  const rowOffsets = [0, 0.5, 1.0];

  // Build key position map and list of valid keys (letters + space)
  const keyPos = {};
  const keyList = [];
  rows.forEach((r, ry) => {
    r.forEach((k, kx) => {
      keyPos[k] = { x: kx + rowOffsets[ry], y: ry };
      keyList.push(k);
    });
  });
  // add space as a special key placed centered under the bottom row
  keyPos[' '] = { x: 3.5, y: 3 };
  keyList.push(' ');

  // compute maximum distance between any two keys (for normalization)
  let maxDist = 1;
  (function calcMax(){
    let md = 0;
    for(let a of keyList){
      for(let b of keyList){
        const pa = keyPos[a], pb = keyPos[b];
        const d = Math.hypot(pa.x - pb.x, pa.y - pb.y);
        if(d > md) md = d;
      }
    }
    maxDist = md || 1;
  })();

  // DOM refs
  const centerKeyEl = document.getElementById('centerKey');
  const subTextEl = document.getElementById('subText');
  const allowedRowEl = document.getElementById('allowedRow');
  const lastKeyEl = document.getElementById('lastKey');
  const colorPanel = document.getElementById('colorPanel');
  const movesEl = document.getElementById('moves');
  const metaEl = document.getElementById('meta');
  const warningArea = document.getElementById('warningArea');
  const treasureHint = document.getElementById('treasureHint');
  const restartBtn = document.getElementById('restartBtn');
  const revealBtn = document.getElementById('revealBtn');

  // game state
  let treasure = null;       // key that is treasure
  let selected = null;       // current selected key (last pressed)
  let moveCount = 0;
  let locked = false;        // true after win until restart

  // choose random treasure
  function pickRandomTreasure(){
    const idx = Math.floor(Math.random() * keyList.length);
    treasure = keyList[idx];
  }

  // compute neighbors: one-step keys from 'k' (diagonals allowed)
  function getNeighbors(k){
    if(!keyPos[k]) return [];
    const p = keyPos[k];
    const neighbors = [];
    for(const other of keyList){
      if(other === k) continue;
      const q = keyPos[other];
      const dx = Math.abs(p.x - q.x);
      const dy = Math.abs(p.y - q.y);
      // threshold tuned to include direct and diagonal neighbors, include space where appropriate
      // allow neighbors where Euclidean distance <= 1.45 (this captures adjacent keys)
      if(Math.hypot(dx,dy) <= 1.45){
        neighbors.push(other);
      }
    }
    // sort neighbors to present in deterministic order (space at end)
    neighbors.sort((a,b)=>{
      if(a === ' ') return 1;
      if(b === ' ') return -1;
      return a.localeCompare(b);
    });
    return neighbors;
  }

  // color mapping: distance -> hue (0 = red near, 220 = blue far)
  function colorForDistance(dist){
    const t = Math.min(1, Math.max(0, dist / maxDist));
    const hue = (1 - t) * 0 + t * 220; // 0 (red) -> 220 (blue)
    const sat = 72 + (1 - t) * 8;
    const light = 52 - t * 6;
    return `hsl(${hue} ${sat}% ${light}%)`;
  }

  // update UI based on selected (last pressed)
  function updateUI(){
    // moves count
    movesEl.textContent = String(moveCount);

    // update last key display
    if(selected == null){
      centerKeyEl.textContent = 'â€”';
      lastKeyEl.textContent = 'â€”';
      subTextEl.textContent = 'Press any key to choose a starting key.';
      allowedRowEl.innerHTML = `<div class="chip">Any letter or Space</div>`;
      colorPanel.style.background = 'linear-gradient(180deg, rgba(255,255,255,0.01), rgba(255,255,255,0.01))';
      metaEl.textContent = `Treasure: hidden`;
      treasureHint.textContent = 'hidden';
      return;
    }

    const disp = selected === ' ' ? 'SPACE' : selected.toUpperCase();
    centerKeyEl.textContent = disp;
    lastKeyEl.textContent = disp;

    // compute distance
    const psel = keyPos[selected];
    const pt = keyPos[treasure];
    const dist = Math.hypot(psel.x - pt.x, psel.y - pt.y);

    // color
    const col = colorForDistance(dist);
    colorPanel.style.background = `linear-gradient(180deg, ${col}, rgba(0,0,0,0.08))`;
    colorPanel.style.boxShadow = `inset 0 8px 40px rgba(0,0,0,.45), 0 10px 40px rgba(0,0,0,.25)`;

    subTextEl.textContent = `Distance: ${dist.toFixed(2)} (normalized ${(dist/maxDist).toFixed(2)})`;

    // show allowed neighbors (one-step)
    const neighbors = getNeighbors(selected);
    allowedRowEl.innerHTML = '';
    if(neighbors.length === 0){
      // shouldn't happen, but safe
      allowedRowEl.innerHTML = `<div class="chip">â€”</div>`;
    } else {
      for(const n of neighbors){
        const chip = document.createElement('div');
        chip.className = 'chip allowed' + (n===' ' ? ' space' : '');
        chip.textContent = n === ' ' ? 'SPACE' : n.toUpperCase();
        allowedRowEl.appendChild(chip);
      }
    }

    // meta info
    metaEl.textContent = `Moves: ${moveCount}`;

    // win check
    if(selected === treasure){
      locked = true;
      // reveal and show celebration
      treasureHint.textContent = selected === ' ' ? 'SPACE' : selected.toUpperCase();
      showWin();
    } else {
      treasureHint.textContent = 'hidden';
    }
  }

  function showWin(){
    // quick visual flash
    colorPanel.style.transition = 'background-color .12s linear, transform .18s ease';
    colorPanel.style.background = 'linear-gradient(180deg, #ffd166, #ff9f0a)';
    centerKeyEl.style.transform = 'scale(1.06) translateY(-6px)';
    subTextEl.textContent = 'ðŸŽ‰ You found the treasure! Press Enter to restart.';
    // small confetti-like text in warning area
    warningArea.innerHTML = `<div style="padding:10px;border-radius:10px;background:linear-gradient(90deg,#fff4cc,#ffe6d0);color:#5a3300;font-weight:800">Treasure revealed: ${selected === ' ' ? 'SPACE' : selected.toUpperCase()}</div>`;
  }

  function showWarning(msg){
    warningArea.innerHTML = `<div class="warning">${msg}</div>`;
    // clear after 1.2s
    setTimeout(()=> {
      if(!locked) warningArea.innerHTML = '';
    }, 1200);
  }

  // handle physical keyboard input
  window.addEventListener('keydown', (ev)=>{
    // ignore modifier keys
    if(ev.metaKey || ev.altKey || ev.ctrlKey) return;

    // restart on Enter
    if(ev.key === 'Enter'){
      ev.preventDefault();
      restartGame();
      return;
    }

    // accept Space explicitly
    let pressed = null;
    if(ev.code === 'Space' || ev.key === ' ' || ev.key === 'Spacebar'){
      pressed = ' ';
      ev.preventDefault();
    } else {
      // normalized single character keys
      const k = (ev.key || '').toLowerCase();
      if(k.length === 1 && k >= 'a' && k <= 'z'){
        pressed = k;
      } else {
        // ignore any other key
        return;
      }
    }

    // if game locked (already won) ignore further keys
    if(locked) {
      showWarning('Game finished. Press Enter to restart.');
      return;
    }

    // if no selection yet, accept any valid pressed key as start
    if(selected === null){
      selected = pressed;
      moveCount = 1;
      updateUI();
      return;
    }

    // otherwise, pressed key must be one-step neighbor from selected
    const allowed = getNeighbors(selected);
    if(allowed.includes(pressed)){
      selected = pressed;
      moveCount += 1;
      updateUI();
    } else {
      // not allowed move
      showWarning(`Not allowed â€” you can only press one of: ${allowed.map(x=>x===' ' ? 'SPACE' : x.toUpperCase()).join(', ')}`);
    }
  });

  // reveal and restart buttons
  revealBtn.addEventListener('click', ()=> {
    alert('Treasure is: ' + (treasure === ' ' ? 'SPACE' : treasure.toUpperCase()));
  });
  restartBtn.addEventListener('click', restartGame);

  function restartGame(){
    pickRandomTreasure();
    selected = null;
    moveCount = 0;
    locked = false;
    warningArea.innerHTML = '';
    treasureHint.textContent = 'hidden';
    centerKeyEl.style.transform = '';
    colorPanel.style.transition = 'background-color .24s linear, box-shadow .24s ease';
    updateUI();
  }

  // initialize
  pickRandomTreasure();
  updateUI();

  // expose debug to console (optional)
  window._topf = {
    keyPos, keyList, getNeighbors, pickRandomTreasure
  };

})();
</script>
</body>
</html>
