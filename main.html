<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8"/>
<title>Where did I leave it again?</title>

<style>

  html, body {
    font-family: "Courier New", Courier, monospace;
    height: 100%;
    margin: 0;
    background: darkslategrey;
    transition: background 0.4s ease;
  }
  #author {
    position: fixed;      /* stays in place even on scroll */
    bottom: 12px;         /* distance from bottom */
    right: 12px;          /* distance from right */
    font-size: 13px;
    color: floralwhite;/*rgba(255,255,255,0.7);*/
  }
  #stats {
    position: fixed;
    top: 16px;
    left: 20px;
    display: flex;
    gap: 20px;
    font-size: 18px;
    padding: 12px 18px;
    z-index: 10;
    color: floralwhite;
  }
  #centerKey {
    position: fixed;
    top: 50%;
    left: 50%;
    transform: translate(-50%, -50%);
    font-size: 120px;
    font-weight: 300;
    color: floralwhite;
  }

</style>


</head>
<body>
<div id="intro-screen">
    <header>
      
    </header>

</div>
   <div id="author">by jqpz</div>

   <div id="stats">
      <div class="label">Moves:</div>
      <div class="value" id="moveCount">0</div>
      <div class="label">Time: </div>
      <div class="value" id="timer">00:00:00</div>
  </div>

  <div id="centerKey">â€”</div>


<script>

  //stats

    let moveCount = 0;
    let startTime = Date.now();
    let timeElapsed = 0;
    const moveEl = document.getElementById('moveCount');
    const timerEl = document.getElementById('timer');

    function formatTime(ms) {
      const totalSeconds = Math.floor(ms / 1000);
      const minutes = Math.floor(totalSeconds / 60);
      const seconds = totalSeconds % 60;
      const centiseconds = Math.floor((ms % 1000) / 10);

      const mm = String(minutes).padStart(2, '0');
      const ss = String(seconds).padStart(2, '0');
      const cs = String(centiseconds).padStart(2, '0');

      return `${mm}:${ss}:${cs}`;
    }

    // Timer updates every 10 ms
    setInterval(() => {
      const elapsed = Date.now() - startTime;
      timerEl.textContent = formatTime(elapsed);
    }, 80);

    // Count moves when any key is pressed
    window.addEventListener('keydown', (e) => {
      if (e.key.length === 1 && e.key.match(/[a-z]/i)) {
        moveCount++;
        moveEl.textContent = moveCount;
      }
    });

  // center Key


  //background
    (function() {
    // QWERTY keyboard layout
    const rows = [
      ['q','w','e','r','t','y','u','i','o','p'],
      ['a','s','d','f','g','h','j','k','l'],
      ['z','x','c','v','b','n','m']
    ];
    const rowOffsets = [0, 0.5, 1.0];
    const keyPos = {};
    const keyList = [];

    // Assign 2D coordinates to each key
    rows.forEach((r, ry) => {
      r.forEach((k, kx) => {
        keyPos[k] = { x: kx + rowOffsets[ry], y: ry };
        keyList.push(k);
      });
    });

    // Compute maximum distance between any two keys
    let maxDist = 1;
    (function calcMax(){
      let md = 0;
      for(let a of keyList){
        for(let b of keyList){
          const pa = keyPos[a], pb = keyPos[b];
          const d = Math.hypot(pa.x - pb.x, pa.y - pb.y);
          if(d > md) md = d;
        }
      }
      maxDist = md || 1;
    })();

    // Random treasure
    let treasure = keyList[Math.floor(Math.random() * keyList.length)];
    let selected = null;

    function getNeighbors(k){
    if(!keyPos[k]) return [];
    const p = keyPos[k];
    return keyList.filter(other => {
      if(other === k) return false;
      const q = keyPos[other];
      return Math.hypot(p.x - q.x, p.y - q.y) <= 1.45;
    });
    }

    // color mapping: distance -> hue (0 = red near, 220 = blue far)
    function colorForDistance(dist){
      const t = Math.min(1, Math.max(0, dist / maxDist));
      const hue = (1 - t) * 0 + t * 220; // 0 (red) -> 220 (blue)
      const sat = 72 + (1 - t) * 8;
      const light = 52 - t * 6;
      return `hsl(${hue} ${sat}% ${light}%)`;
    }

    // Update background color
    function updateColor() {
      if (!selected) return;
      const psel = keyPos[selected];
      const pt = keyPos[treasure];
      const dist = Math.hypot(psel.x - pt.x, psel.y - pt.y);
      const col = colorForDistance(dist);
      document.body.style.background = `linear-gradient(0deg, ${col}, darkslategrey`;
    }
    const centerEl = document.getElementById('centerKey');


    // Handle key presses
    window.addEventListener('keydown', (ev) => {
      const k = (ev.key || '').toLowerCase();
      if (k.length !== 1 || k < 'a' || k > 'z') return;

      if (selected === null) {
        // First key pressed: allow any
        selected = k;
        centerEl.textContent = k.toUpperCase();
      } else {
        // Only allow neighbors
        const allowed = getNeighbors(selected);
        if (!allowed.includes(k)) return; // invalid key, ignore
        selected = k;
        centerEl.textContent = k.toUpperCase();
      }

      moveCount++;            // increment moves
      moveEl.textContent = moveCount;

      updateColor();          // update background & UI
    });
    })();

  
</script>


</body>
</html>